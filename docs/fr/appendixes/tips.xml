<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.8 Maintainer: didou Status: ready -->
<chapter id="tips">
 <title>Trucs et astuces</title>
 <para></para>
 <sect1 id="tips.blank.var.handling">
  <title>Gestion des variables non-assignées</title>
  <para>
   Peut-être voudrez-vous des fois afficher une valeur par
   défaut pour une variable qui n'a pas été assignée, comme
   pour afficher "&amp;nbsp;" afin que les couleurs de fond
   des tableaux fonctionnent. Beaucoup utiliseraient une
   instruction <link linkend="language.function.if">{if}</link> 
   pour gérer celà, mais il existe un moyen
   plus facile dans Smarty : l'utilisation du modificateur
   de variable <emphasis>default</emphasis>.
  </para>
  <example>
   <title>afficher &amp;nbsp; quand une variable est vide</title>
   <programlisting>
<![CDATA[
{* la méthode pas adaptée *}

{if $title eq ""}
   &nbsp;
{else}
   {$title}
{/if}


{* la bonne méthode *}

{$title|default:"&nbsp;"}
]]>
   </programlisting>
  </example>
  <para>
   Voir aussi 
   <link linkend="language.modifier.default">default</link> et
   <link linkend="tips.default.var.handling">la gestion des variables par défaut</link>.
  </para>
 </sect1>

 <sect1 id="tips.default.var.handling">
  <title>Gestion des variables par défaut</title>
  <para>
   Si une variable est utilisée fréquemment dans vos templates,
   lui appliquer le modificateur par défaut peut être un peu fastidieux.
   Vous pouvez remédier à celà en lui assignant une valeur par défaut
   avec la fonction <link linkend="language.function.assign">{assign}</link>.
  </para>
  <example>
   <title>assigner une valeur par défaut à une variable de template</title>
<programlisting>
<![CDATA[
{* faites celà quelque part en haut de votre template *}
{assign var="title" value=$title|default:"no title"}

{* si $title est vide, il contiendra alors la valeur "no title" *}
{$title}
]]>
   </programlisting>
  </example>
  <para>
   Voir aussi
   <link linkend="language.modifier.default">default</link> et
   <link linkend="tips.blank.var.handling">la gestion des variables non-assignées</link>.
  </para>
 </sect1>
 <sect1 id="tips.passing.vars">
  <title>Passage du titre à un template d'en-tête</title>
  <para>
   Quand la majorité de vos templates utilisent les mêmes en-tête et pied-de-page,
   il est d'usage de les mettre dans leurs propres templates et de les inclure.
   Mais comment faire si l'en-tête doit avoir un titre différent, selon la page
   d'où on vient ? Vous pouvez passer le titre à l'en-tête quand il est inclus.
  </para>
  <example>
   <title>passer le titre au template d'en-tête</title>
   <programlisting>
<![CDATA[
mainpage.tpl
------------

{include file="header.tpl" title="Main Page"}
{* le corps du template va ici *}
{include file="footer.tpl"}


archives.tpl
------------

{config_load file="archive_page.conf"}
{include file="header.tpl" title=#archivePageTitle#}
{* le corps du template va ici *}
{include file="footer.tpl"}


header.tpl
----------
<HTML>
<HEAD>
<TITLE>{$title|default:"BC News"}</TITLE>
</HEAD>
<BODY>


footer.tpl
----------
</BODY>
</HTML>
]]>
   </programlisting>
  </example>
  <para>
   Quand la page principale est conçue, le titre "Main page" est passé à header.tpl
   et sera donc utilisé pour le titre. Quand la page d'archive est conçue,
   le titre sera "Archives". Notez que dans l'exemple des archives, on utilise
   le fichier archives_page.conf plutôt que des variables codées en dur.
   Remarquez aussi que "BC News" est affichée si la variable $title
   n'est pas définie, grâce au modificateur de variable 
   <link linkend="language.modifier.default">default</link>.
  </para>
 </sect1>
 <sect1 id="tips.dates">
  <title>Dates</title>
  <para>
   De façon générale, essayez de toujours passer les dates à Smarty
   sous forme de timestamp. Celà permet aux designers de templates d'utiliser
   <link linkend="language.modifier.date.format">date_format</link>
    pour avoir un contrôle total sur le formatage des dates et de comparer
    facilement les dates entre elles.
   </para>
   <note>
    <para>
     A partir Smarty 1.4.0, vous pouvez passer les dates à Smarty
     sous la forme de timestamps Unix ou MySQL, ou tout autre format de dates
     que comprend <ulink url="&url.php-manual;strtotime">strtotime()</ulink>.
    </para>
   </note>
   <example>
    <title>Utilisation de date_format</title>
    <programlisting>
<![CDATA[
{$startDate|date_format}
]]>
    </programlisting>
    <para>
     Affichera :
    </para>
    <screen>
<![CDATA[
Jan 4, 2001
]]>
    </screen>
    <programlisting>
<![CDATA[
{$startDate|date_format:"%Y/%m/%d"}
]]>
    </programlisting>
    <para>
     Affichera :
    </para>
    <screen>
<![CDATA[
2001/01/04
]]>
    </screen>
    <programlisting>
<![CDATA[
{if $date1 < $date2}
   ...
{/if}
]]>
    </programlisting>
   </example>
   <para>
    En utilisant la fonction <link linkend="language.function.html.select.date">{html_select_date}</link> 
    dans un template, le programmeur
    veut en général convertir le résultat d'un formulaire en un timestamp.
    Voici une fonction qui devrait vous être utile.
   </para>
   <example>
    <title>Conversion des éléments date d'un formulaire en timestamp</title>
    <programlisting role="php">
<![CDATA[
<?php

// celà suppose que vos éléments de formulaire soient nommés
// startDate_Day, startDate_Month, startDate_Year

$startDate = makeTimeStamp($startDate_Year, $startDate_Month, $startDate_Day);

function makeTimeStamp($year="", $month="", $day="")
{
   if(empty($year)) {
       $year = strftime("%Y");
   }
   if(empty($month)) {
       $month = strftime("%m");
   }
   if(empty($day)) {
       $day = strftime("%d");
   }

   return mktime(0, 0, 0, $month, $day, $year);
}
?>
]]>
    </programlisting>
   </example>
   
   <para>
    Voir aussi
    <link linkend="language.function.html.select.date">{html_select_date}</link>,
    <link linkend="language.function.html.select.time">{html_select_time}</link>,
    <link linkend="language.modifier.date.format">date_format</link>
    et <link linkend="language.variables.smarty.now">$smarty.now</link>,
   </para>

  </sect1>
  <sect1 id="tips.wap">
   <title>WAP/WML</title>
   <para>
    Les templates WAP/WML nécessitent un en-tête "Content-Type" qui doit être
    passé avec le template. Le moyen le plus facile de faire celà est d'écrire
    une fonction utilisateur qui écrit l'en-tête. Si vous utilisez le cache,
    celà ne fonctionnera pas. Nous utiliserons donc une balise d'insertion
    (rappelez-vous que les balises d'insertion ne sont pas mises en cache !).
    Assurez-vous qu'aucune sortie
    rien n'est transmise au navigateur avant l'appel du template, sans quoi
    la modification de l'en-tête échouera.
   </para>
   <example>
    <title>Utilisation d'insert pour écrire un en-tête Content-Type WML</title>
    <programlisting role="php">
<![CDATA[
<?php

// assurez-vous que Apache est configuré pour les extensions .wml !
// mettez cette fonction quelque part dans votre applications
// ou dans Smarty.addons.php
function insert_header() 
{
   // cette fonction attend un argument $content
   if (empty($params['content'])) {
       return;
   }
   header($params['content']);
   return;
}

?>
]]>
    </programlisting>
    <para>
     votre template Smarty <emphasis>doit</emphasis> commencer avec la balise d'insertion :
    </para>
    <programlisting>
<![CDATA[
{insert name=header content="Content-Type: text/vnd.wap.wml"}

<?xml version="1.0"?>  
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"> 

<!-- begin new wml deck --> 
<wml> 
 <!-- begin first card --> 
 <card> 
  <do type="accept"> 
   <go href="#two"/> 
  </do>  
  <p> 
   Welcome to WAP with Smarty!
   Press OK to continue...  
  </p> 
 </card>  
 <!-- begin second card --> 
 <card id="two">  
  <p> 
   Pretty easy isn't it?
  </p> 
 </card> 
</wml>
]]>
    </programlisting>
   </example>
  </sect1>
  <sect1 id="tips.componentized.templates">
   <title>Templates composants</title>
   <para>
    Traditionnellemnt, la programmation avec des templates dans les applications
    se déroule de la façon suivante : d'abord vous récupérez vos variables
    dans l'application PHP (peut-être avec des requêtes en base de données), puis
    vous instanciez votre objet Smarty, <link linkend="api.assign">assignez</link> 
    les variables et <link linkend="api.display">affichez</link> le
    template. Disons par exemple que nous avons un téléscripteur dans
    notre template. Nous récupérerions les données dans notre application,
    puis les assignerions ensuite pour les afficher. Mais ne serait-ce pas
    mieux de pouvoir ajouter ce téléscripteur à n'importe quelle application
    en incluant directement le template sans avoir à se soucier de la récupération
    des données ?
   </para>
   <para>
    Vous pouvez réaliser celà en écrivant un plugin personnalisé pour récupérer le contenu
    et l'assigner à une variable du template.
   </para>
   <example>
    <title>Template composant</title>
    <programlisting role="php">
<![CDATA[
<?php

// Efface le fichier "function.load_ticker.php" dans le répertoire des plugins

// notre fonction pour récupérer les données
function fetch_ticker($symbol,&amp;$ticker_name,&amp;$ticker_price) 
{
   // du traitement qui récupère $ticker_name
   // depuis la ressource ticker
   return $ticker_info;
}

function smarty_function_load_ticker($params, &$smarty) 
{
   // appel de la fonction
   $ticker_info = fetch_ticker($params['symbol']);
   
   // assignation de la variable de template
   $smarty->assign($params['assign'], $ticker_info);
}
?>
]]>
    </programlisting>
    <programlisting>
<![CDATA[
{* in index.tpl *}

{load_ticker symbol="YHOO" assign="ticker"}

Stock Name: {$ticker.name} Stock Price: {$ticker.price}
]]>
    </programlisting>
   </example>
   <para>
    Voir aussi
    <link linkend="language.function.include.php">{include_php}</link>,
    <link linkend="language.function.include">{include}</link> et
    <link linkend="language.function.php">{php}</link>.
   </para>
  </sect1>
  <sect1 id="tips.obfuscating.email">
   <title>Dissimuler les adresses email</title>
   <para>
    Vous-êtes vous déjà demandé pourquoi vos adresses emails sont sur autant
    de listes de diffusion de spam ? Une façon pour les spammers de récupérer les
    adresses est de parcourir les pages Web. Voici une façon de remédier
    à ce problème : mettre votre adresse email dans du Javascript brouillé
    au milieu de votre source HTML, sans que celà ne gêne l'affichage sur le
    navigateur Web. Celà est fait grâce au plugin mailto.
   </para>
   <example>
    <title>Exemple de dissimulation d'une adresse email</title>
<programlisting>
<![CDATA[
{* in index.tpl *}

Send inquiries to
{mailto address=$EmailAddress encode="javascript" subject="Hello"}
]]>
    </programlisting>
   </example>
   <note>
    <title>Note technique</title>
    <para>
     Cette méthode n'est pas infaillible. Un spammer peut programmer son
     collecteur d'email pour passer outre cette astuce, mais c'est cependant
     peu probable.
    </para>
   </note>
   <para>
    Voir aussi
    <link linkend="language.modifier.escape">escape</link>.
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
