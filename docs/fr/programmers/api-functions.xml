<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
   <chapter id="api.functions">
     <title>MTthodes</title>
        <sect1 id="api.append">
         <title>append</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
           <paramdef>boolean <parameter>merge</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour ajouter un TlTment a un tableau assignT. Si vous utilisez
         cette fonction avec une chaene de caractFre, elle est convertie en
         tableau auquel on ajoute ensuite l'TlTment. Vous pouvez explicitement passer
         des paires nom/valeur. Si vous passez le troisiFme paramFtre
         (optionel) a vrai, la valeur sera fusionnTe avec le tableau plut(t que
         d'Otre ajoutTe.
         </para>
		 <note>
		 <title>Note technique</title>
		 <para>
		 Le paramFtre de fusion respecte les clTs des tableaux, ainsi si vous
		 fusionnez deux tableaux indexTs numTriquement, ils pourront s'Tcraser
		 l'un l'autre ou donner des clTs qui ne se suivent pas. Cela diffFre
		 donc de la fonction PHP array_merge() qui supprime les clTs numTriques
		 et les renumTrote.
		 </para>
		 </note>
         <example>
          <title>append</title>
          <programlisting>
// passe des paires nom/valeur
$smarty->append("Name","Fred");
$smarty->append("Address",$address);

// passe un tableau associatif
$smarty->append(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.append.by.ref">
      <title>append_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
        <paramdef>boolean <parameter>merge</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      UtilisTe pour ajouter des valeurs a un template par rTfTrence plut(t que
      par copie. Si vous ajoutez une variable par rTfTrence puis changez sa
      valeur, le changement est aussi rTpercutT sur la valeur assignTe.
      Pour les objets, append_by_ref ne fait pas de copie en mTmoire de l'objet
      assignT. Voir la documentation PHP pour plus d'informations sur les
      rTfTrences de variable.
      Si vous passez le troisiFme paramFtre a vrai, la valeur sera fusionnTe
      avec le tableau courant plut(t que d'Otre ajoutTe.
      </para>
	  <note>
	  <title>Note technique</title>
     <para>
       Le paramFtre de fusion respecte les clTs des tableaux, ainsi si vous
      fusionnez deux tableaux indexTs numTriquement, ils pourront s'Tcraser
      l'un l'autre ou donner des clTs qui ne se suivent pas. Cela diffFre
      donc de la fonction PHP array_merge() qui supprime les clTs numTriques
      et les renumTrote.
     </para>
	  </note>
      <example>
       <title>append_by_ref</title>
       <programlisting>
// ajoute des paires nom/valeur
$smarty->append_by_ref("Name",$myname);
$smarty->append_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign">
      <title>assign</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      UtilisTe pour assigner des valeurs aux templates. Vous pouvez
      explicitement passer des paires nom/valeur, ou des tableaux
      associatifs contenant des paires nom/valeur.
      </para>
      <example>
       <title>assign</title>
       <programlisting>
// passe des paires nom/valeur
$smarty->assign("Name","Fred");
$smarty->assign("Address",$address);

// passe un tableau associatif
$smarty->assign(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign.by.ref">
      <title>assign_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      UtilisTe pour assigner des valeurs aux templates par rTfTrence plut(t
      que par copie. RTfTrez-vous au manuel PHP pour une explication plus prTcise
      sur les rTfTrences des variables.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	    Si vous assignez une variable par rTfTrence puis changez sa
      valeur, le changement est aussi rTpercutT sur la valeur assignTe.
      Pour les objets, assign_by_ref ne fait pas de copie en mTmoire de l'objet
      assignT. RTfTrez-vous au manuel PHP pour une explication plus prTcise sur
      les rTfTrences de variable.
	  </para>
	  </note>
      <example>
       <title>assign_by_ref</title>
       <programlisting>
// passe des paires noms/valeurs
$smarty->assign_by_ref("Name",$myname);
$smarty->assign_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.assign">
			<title>clear_all_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_assign</function></funcdef>
				<paramdef><parameter></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour effacer les valeurs de toutes les variables assignTes.
			</para>
<example>
<title>clear_all_assign</title>
<programlisting>
// efface toutes les variables assignTes
$smarty->clear_all_assign();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.cache">
			<title>clear_all_cache</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_cache</function></funcdef>
				<paramdef>int <parameter>expire time</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour effacer les fichiers de cache des templates. Vous pouvez passer un
         paramFtre optionnel afin d'indiquer l'Gge minimun que doivent avoir
         les fichiers  de cache pour qu'ils soient effacTs.
			</para>
<example>
<title>clear_all_cache</title>
<programlisting>
// efface le cache
$smarty->clear_all_cache();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.assign">
			<title>clear_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_assign</function></funcdef>
				<paramdef>string <parameter>var</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
         <para>
         Efface la valeur d'une variable assignTe. Il peut s'agir
         d'une simple valeur ou d'un tableau de valeur.
         </para>
<example>
<title>clear_assign</title>
<programlisting>
// efface une variable
$smarty->clear_assign("Name");

// efface plusieurs variables
$smarty->clear_assign(array("Name","Address","Zip"));</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.cache">
			<title>clear_cache</title>
   <methodsynopsis>
    <type>void</type><methodname>clear_cache</methodname>
    <methodparam choice="opt"><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>expire time</parameter></methodparam>
   </methodsynopsis>
			<para>
			UtilisTe pour nettoyer le(s) fichier(s) de cache d'un template en particulier.
			Si vous avez plusieurs fichiers de cache pour ce template vous
			pouvez en spTcifier un en  particulier en passant son identifiant
			en deuxiFme paramFtre. Vous pouvez aussi passer un identifiant
			de compilation en troisiFme paramFtre. Vous pouvez grouper des
			templates ensemble afin qu'ils puissent Otre supprimTs en groupe.
			RTfTrez-vous a la section sur le
			<link linkend="caching">cache</link>
			pour plus d'informations. Vous pouvez passer un quatriFme paramFtre
			pour indiquer un Gge minimum en secondes que le fichier en cache doit
			avoir avant d'Otre effacT.
			</para>
<example>
<title>clear_cache</title>
<programlisting>
// efface le fichier de cache de ce template
$smarty->clear_cache("index.tpl");

// efface un fichier de cache grGce a son identifiant de cache
$smarty->clear_cache("index.tpl","CACHEID");</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.compiled.tpl">
			<title>clear_compiled_tpl</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_compiled_tpl</function></funcdef>
				<paramdef>string <parameter>tpl_file</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour effacer la version compilTe du template spTcifiT ou
			de tous les templates si aucun n'est spTcifiT. Cette fonction
			est destinTe a un usage avancT et n'est pas habituellement utilisTe.
			</para>
<example>
<title>clear_compiled_tpl</title>
<programlisting>
// efface la version compilTe du template spTcifiT
$smarty->clear_compiled_tpl("index.tpl");

// efface tout le contenu du rTpertoire des templates compilTs
$smarty->clear_compiled_tpl();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.config">
			<title>clear_config</title>
   <methodsynopsis>
    <type>void</type><methodname>clear_config</methodname>
    <methodparam choice="opt"><type>string</type><parameter>var</parameter></methodparam>
   </methodsynopsis>
			<para>
         UtilisTe pour effacer toutes les variables de configuration s'Ttant
         vues assigner une valeur. Si une variable est spTcifiTe, seule cette
         variable est effacTe.
			</para>
<example>
<title>clear_config</title>
<programlisting>
// efface toutes les variables de configuration assignTes
$smarty->clear_config();

// efface une seule variable
$smarty->clear_config('foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.config.load">
			<title>config_load</title>
   <methodsynopsis>
    <type>void</type><methodname>config_load</methodname>
    <methodparam><type>string</type><parameter>file</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>section</parameter></methodparam>
   </methodsynopsis>
			<para>
			UtilisTe pour charger des donnTes d'un fichier de config et les
			assigner a un template. Cette fonction fonctionne exactement comme
			la fonction de template <link
			linkend="language.function.config.load">config_load</link>.
			</para>
		  <note>
		  <title>Note technique</title>
		  <para>
		  Comme pour Smarty 2.4.0, les variables de templates assignTes
        sont conservTes entre chaque appel a fetch et display.
		  Les variables de configuration chargTes avec config_load sont
        globales. Les fichiers de config sont aussi compilTs pour une
        exTcution plus rapide et respecte les rTglages de <link
		   linkend="variable.force.compile">force_compile</link> et de <link
		   linkend="variable.compile.check">compile_check</link>.
		  </para>
		  </note>
<example>
<title>config_load</title>
<programlisting>
// charge les variables de configuration et les assigne
$smarty->config_load('my.conf');

// charge une section
$smarty->config_load('my.conf','foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.display">
			<title>display</title>
   <methodsynopsis>
    <type>void</type><methodname>display</methodname>
    <methodparam><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
   </methodsynopsis>
			<para>
         UtilisTe pour afficher un template. Il faut fournir un type et un
         chemin de <link
                linkend="template.resources">ressource template</link>
         valides. Vous pouvez passer en second paramFtre un identifiant
         de fichier de cache. Reportez-vous a la section
         <link linkend="caching">cache</link> pour plus de renseignements.
			</para>
			<para>
			Le troisiFme paramFtre optionnel est un identifiant de compilation.
         Cela s'avFre utile quand vous voulez compiler diffTrentes versions
         d'un mOme template, pour par exemple avoir des templates
         compilTs sTparTs pour diffTrents langages. Une autre utilitT de ce
         paramFtre est le cas oú vous utilisez plus d'un $template_dir mais un seul
         $compile_dir, car certains templates avec le mOme nom s'Tcraseraient
         entre eux. Vous pouvez aussi rTgler la variable <link
			linkend="variable.compile.id">$compile_id</link> une seule
			fois au lieu de la passer a chaque appel.
			</para>
<example>
<title>affichage</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;
$smarty->caching = true;

// ne fait un appel a la base de donnTes que si le fichier
// de cache n'existe pas
if(!$smarty->is_cached("index.tpl"))
{

    // quelques donnTes
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// display the output
$smarty->display("index.tpl");</programlisting>
</example>
         <para>
         Utilisez la syntaxe des <link
			linkend="template.resources">ressources templates</link>
         pour afficher des fichiers en-dehors du rTpertoire
         $template_dir
         </para>

<example>
<title>exemples de fonction d'affichage de ressources templates</title>
<programlisting>
// chemin absolu
$smarty->display("/usr/local/include/templates/header.tpl");

// chemin absolu (pareil)
$smarty->display("file:/usr/local/include/templates/header.tpl");

// chemin absolu Windows (on DOIT utiliser le prTfixe "file:")
$smarty->display("file:C:/www/pub/templates/header.tpl");

// inclue a partir de la ressource template "db"
$smarty->display("db:header.tpl");</programlisting>
</example>

		</sect1>
		<sect1 id="api.fetch">
			<title>fetch</title>
   <methodsynopsis>
    <type>string</type><methodname>fetch</methodname>
    <methodparam><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
   </methodsynopsis>
			<para>
			UtilisTe pour renvoyer le rTsultat du template plut(t que de l'afficher.
         Il faut passer un type et un chemin de <link
         linkend="template.resources">ressource template</link>
         valides. Vous pouvez passer un identifiant de cache en deuxiFme
         paramFtre. Reportez-vous a la section <link linkend="caching">cache
         </link> pour plus de renseignements.
			</para>
			<para>
         Un troisiFme paramFtre optionnel est un identifiant de compilation.
         Cela s'avFre utile quand vous voulez compiler diffTrentes versions
         d'un mOme template, pour par exemple avoir des templates
         compilTs sTparTs pour diffTrents langages. Une autre utilitT de ce
         paramFtre est le cas oú vous utilisez plus d'un $template_dir
         mais un seul $compile_dir, car certains templates avec le mOme nom
         s'Tcraseraient entre eux. Vous pouvez aussi rTgler la variable <link
			linkend="variable.compile.id">$compile_id</link> une seule
			fois plut(t que de la passer a chaque appel.
			</para>
<example>
<title>fetch</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;

$smarty->caching = true;

// ne fait un appel a la base de donnTes que si le fichier
// de cache n'existe pas
if(!$smarty->is_cached("index.tpl"))
{

    // quelques donnTes
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// rTcupFre le rTsultat
$output = $smarty->fetch("index.tpl");

// fait quelque chose avec $output

echo $output;</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.config.vars">
			<title>get_config_vars</title>
   <methodsynopsis>
    <type>array</type><methodname>get_config_vars</methodname>
    <methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
   </methodsynopsis>
			<para>
			Retourne la valeur de la variable de configuration passTe en paramFtre.
			Si aucun paramFtre n'est donnT, un tableau de toutes les variables de
			configuration chargTes est renvoyT.
			</para>
<example>
<title>get_config_vars</title>
<programlisting>
// rTcupFre la variable de configuration chargTe 'foo'
$foo = $smarty->get_config_vars('foo');

// rTcupFre toutes les variables de configuration chargTes
$config_vars = $smarty->get_config_vars();

// les affiche a l'Tcran
print_r($config_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.registered.object">
			<title>get_registered_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_registered_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne la rTfTrence d'un objet enregistrT. Utile quand vous
			voulez accTder directement a un objet enregistrT avec une
			fonction utilisateur.
			</para>
<example>
<title>get_registered_object</title>
<programlisting>
function smarty_block_foo($params, &amp;$smarty) {
	if (isset[$params['object']]) {
      // rTcupFre la rTfTrence de l'objet enregistrT
   		$obj_ref =&amp; $smarty->get_registered_object($params['object']);
   	// $obj_ref est maintenant une rTfTrence vers l'objet
	}
}</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.template.vars">
			<title>get_template_vars</title>
   <methodsynopsis>
    <type>array</type><methodname>get_template_vars</methodname>
    <methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
   </methodsynopsis>
			<para>
			Retourne la valeur assignTe passTe en paramFtre. Si aucun paramFtre
			n'est donnT, un tableau de toutes les variables assignTes est
			renvoyT.
			</para>
<example>
<title>get_template_vars</title>
<programlisting>
// rTcupFre la variable 'foo' assignTe au template
// get assigned template var 'foo'
$foo = $smarty->get_template_vars('foo');

// rTcupFre toutes les variables assignTes a ce template
$tpl_vars = $smarty->get_template_vars();

// les affiche a l'Tcran
print_r($tpl_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.is.cached">
			<title>is_cached</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>is_cached</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>[string <parameter>cache_id</parameter>]</paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne vrai s'il y a un fichier de cache valide pour ce template.
			Cela fonctionne seulement si <link
         linkend="variable.caching">caching</link> est a vrai.
			</para>
<example>
<title>is_cached</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl")) {
    // faire des requOtes base de donnTes et assigner
    // des variables ici.
}

$smarty->display("index.tpl");</programlisting>
</example>
            <para>
            Vous pouvez aussi passer en second paramFtre un identifiant
            de cache au cas oú vous voudriez plusieurs fichiers de cache
            pour ce template.
            </para>
<example>
<title>is_cached with multiple-cache template</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl","FrontPage")) {
    // faire des requOtes base de donnTes et assigner
    // des variables ici.
}

$smarty->display("index.tpl","FrontPage");</programlisting>
</example>
		</sect1>
        <sect1 id="api.load.filter">
         <title>load_filter</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>load_filter</function></funcdef>
           <paramdef>string <parameter>type</parameter></paramdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction peut Otre utilisTe pour charger un plugin
         de filtrage. Le premier argument spTcifie le type du filtre
         et peut prendre l'une des valeurs suivantes : 'pre', 'post'
         ou 'output'. Le second argument spTcifie le nom du plugin
         de filtrage, par exemple 'trim'.
         </para>
<example>
<title>Chargement de plugins de filtrage</title>
<programlisting>
$smarty->load_filter('pre', 'trim'); // charge le filtre 'trim' de type 'pre'
$smarty->load_filter('pre', 'datefooter'); // charge un autre filtre de type 'pre' appelT 'datefooter'
$smarty->load_filter('output', 'compress'); // charge le filtre 'compress' de type 'output'</programlisting>
</example>
        </sect1>
		<sect1 id="api.register.block">
			<title>register_block</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_block</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour dTclarrer dynamiquement des plugins de fonction
         de blocs. Il faut passer en paramFtre le nom de la fonction
         de blocs, suivi du nom de la fonction PHP qui l'implTmente.
         </para>
<example>
<title>register_block</title>
<programlisting>
/* PHP */
$smarty->register_block("translate", "do_translation");

function do_translation ($params, $content, &amp;$smarty) {
    if ($content) {
        $lang = $params['lang'];
        // fait de la traduction avec la variable $content
        echo $translation;
    }
}

{* template *}
{translate lang="br"}
   Hello, world!
{/translate}</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.compiler.function">
			<title>register_compiler_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_compiler_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement un plugin de fonction
			de compilation. Il faut passer en paramFtres le nom de la fonction
			de compilation, suivi par la fonction PHP qui
			l'implTmente.
			</para>
		</sect1>
		<sect1 id="api.register.function">
			<title>register_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement des plugins de fonction
			de templates. Il faut passer en paramFtres le nom de la fonction
			de templates, suivi par le nom de la fonction PHP qui l'implTmente.
			</para>
<example>
<title>register_function</title>
<programlisting>
$smarty->register_function("date_now", "print_current_date");

function print_current_date ($params) {
    extract($params);
    if(empty($format))
        $format="%b %e, %Y";
    echo strftime($format,time());
}

// vous pouvez maintenant utiliser ceci dans Smarty pour afficher
// la date actuelle : {date_now} ou {date_now format="%Y/%m/%d"}
// pour la formater</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.modifier">
         <title>register_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>string <parameter>impl</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTclarer dynamiquement un plugin de modificateur.
         Il faut passer en paramFtre le nom du modificateur de variables,
         suivi de la fonction PHP qui l'implTmente.
         </para>
<example>
<title>register_modifier</title>
<programlisting>
// associons la fonction PHP stripslashes a un modificateur Smarty.

$smarty->register_modifier("sslash","stripslashes");

// vous pouvez maintenant utiliser {$var|sslash} pour supprimer les slash des variables</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.object">
			<title>register_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
				<paramdef>object <parameter>$object</parameter></paramdef>
				<paramdef>array <parameter>allowed methods/properties</parameter></paramdef>
				<paramdef>boolean <parameter>format</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour enregistrer un objet a utiliser dans un template.
			Reportez-vous a la section
         <link linkend="advanced.features.objects">objet</link> de
         ce manuel pour des exemples.
         </para>
		</sect1>
		<sect1 id="api.register.outputfilter">
			<title>register_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement des filtres de sortie, pour
			agir sur la sortie d'un template avant qu'elle ne soit affichTe.
			Reportez-vous a la section <link linkend="advanced.features.outputfilters">
         filtres de sortie</link> pour plus d'information sur le sujet.
			</para>
		</sect1>
		<sect1 id="api.register.postfilter">
			<title>register_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour dTclarer dynamiquement des filtres de post-compilation pour y faire
         passer des templates une fois qu'ils ont TtT compilTs. Reportez-vous
         a la section
          <link linkend="advanced.features.postfilters">filtres de post-compilation de templates</link>
         pour avoir plus de renseignements sur la faton de paramTtrer les fonctions
         de post-compilation.
			</para>
		</sect1>
		<sect1 id="api.register.prefilter">
			<title>register_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement des filtres de prT-compilation pour y faire
         passer des templates avant qu'ils ne soient compilTs. Reportez-vous
         a la section
          <link linkend="advanced.features.postfilters">filtres de prT-compilation de templates</link>
         pour avoir plus de renseignements sur la faton de paramTtrer les fonctions
         de prT-compilation.
			</para>
		</sect1>
        <sect1 id="api.register.resource">
         <title>register_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>array <parameter>resource_funcs</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTclarer dynamiquement une ressource plugin
         dans Smarty. Il faut passer en paramFtre le nom de la ressource
         et le tableau des fonctions PHP qui l'implTmentent. Reportez-vous
         a la section <link linkend="template.resources">ressources templates</link>
         pour avoir plus d'informations sur la faton de paramTtrer une fonction
         rTcupTrant des templates.
         </para>
<example>
<title>register_resource</title>
<programlisting>
$smarty->register_resource("db", array("db_get_template",
                                       "db_get_timestamp",
                                       "db_get_secure",
                                       "db_get_trusted"));</programlisting>
</example>
		</sect1>
        <sect1 id="api.trigger.error">
         <title>trigger_error</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>trigger_error</function></funcdef>
           <paramdef>string <parameter>error_msg</parameter></paramdef>
           <paramdef>[int <parameter>level</parameter>]</paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction peut-Otre utilisTe pour afficher un message d'erreur
         en utilisant Smarty. Le paramFtre <parameter>level</parameter>
         peut prendre l'une des valeures utilisTes par la fonction PHP
         trigger_error, i.e. E_USER_NOTICE, E_USER_WARNING, etc. Par dTfaut
         il s'agit de E_USER_WARNING.
         </para>
        </sect1>

        <sect1 id="api.template.exists">
         <title>template_exists</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>bool <function>template_exists</function></funcdef>
           <paramdef>string <parameter>template</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction vTrifie si le template spTcifiT existe. Elle accepte
         soit un chemin vers le template, soit une ressource de type
         chaene de caractFres prTcisant le nom du template.
         </para>
        </sect1>
        <sect1 id="api.unregister.block">
         <title>unregister_block</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_block</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin de fonction
         de blocs. Passez en paramFtre le nom du bloc.
         </para>
		</sect1>
        <sect1 id="api.unregister.compiler.function">
         <title>unregister_compiler_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_compiler_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un fonction de compilation.
         Passez en paramFtre le nom de la fonction de compilation.
         </para>
        </sect1>
		<sect1 id="api.unregister.function">
         <title>unregister_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin de fonction
         de templates. Passez en paramFtres le nom de la fonction de templates.
         </para>
<example>
<title>unregister_function</title>
<programlisting>
// nous ne voulons pas que les designers de templates aient accFs
// au systFme de fichiers.

$smarty->unregister_function("fetch");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.modifier">
         <title>unregister_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin modificateur de variable.
         Passez en paramFtre le nom du modificateur de templates.
         </para>
<example>
<title>unregister_modifier</title>
<programlisting>
// nous ne voulons pas que les designers de templates
// suppriment les balises des Tlements

$smarty->unregister_modifier("strip_tags");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.object">
			<title>unregister_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer un objet.
         </para>
		</sect1>
		<sect1 id="api.unregister.outputfilter">
			<title>unregister_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer dynamiquement un filtre de sortie.
			</para>
		</sect1>
		<sect1 id="api.unregister.postfilter">
			<title>unregister_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer dynamiquement un filtre de post-compilation.
			</para>
		</sect1>
		<sect1 id="api.unregister.prefilter">
			<title>unregister_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer dynamiquement un filtre de prT-compilation.
			</para>
		</sect1>
        <sect1 id="api.unregister.resource">
         <title>unregister_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin ressource.
         Passez en paramFtre le nom de la ressource.
         </para>
<example>
<title>unregister_resource</title>
<programlisting>
$smarty->unregister_resource("db");</programlisting>
</example>
		</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
