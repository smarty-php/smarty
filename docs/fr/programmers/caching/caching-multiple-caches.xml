<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.2 Maintainer: didou Status: ready -->
<sect1 id="caching.multiple.caches">
 <title>Caches multiples pour une seule page</title>
 <para>
  Vous pouvez avoir plusieurs fichiers de caches pour un même appel
  aux fonctions display() ou fetch(). Imaginons qu'un appel a 
  display('index.tpl') puisse avoir plusieurs résultats, en fonction de 
  certaines conditions, et que
  vous vouliez des fichiers de cache séparés pour chacun d'eux. Vous
  pouvez faire cela en passant un identifiant de cache (cache_id) en
  deuxiéme paramétre a l'appel de fonction.
 </para>
 <example>
  <title>Passage d'un cache_id a display()</title>
  <programlisting>
<![CDATA[
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$my_cache_id = $_GET['article_id'];

$smarty->display('index.tpl',$my_cache_id);
]]>
  </programlisting>
 </example>
 <para>
  Nous passons ci-dessus la variable $my_cache_id a display() comme
  identifiant de cache. Pour chaque valeur distincte de $my_cache_id,
  un fichier de cache distinct va être créé. Dans cet exemple,
  "article_id" a été passé dans l'URL et est utilisé en tant qu'identifiant
  de cache.
 </para>
 <note>
  <title>Note technique</title>
  <para>
   Soyez prudent en passant des valeurs depuis un client (navigateur Web)
   vers Smarty (ou vers n'importe quelle application PHP). Bien que l'exemple
   ci-dessus consistant a utiliser article_id depuis l'URL puisse paraetre
   commode, le résultat peut s'avérer mauvais. L'identifiant
   de cache est utilisé pour créer un répertoire sur le systéme de fichiers,
   donc si l'utilisateur décide de donner une trés grande valeur a article_id
   ou d'écrire un script qui envoie des article_id de faton aléatoire,
   cela pourra causer des problémes coté serveur. Assurez-vous de bien
   tester toute donnée passée en paramétre avant de l'utiliser. Dans cet
   exemple, peut-être savez-vous que article_id a une longueur de 10
   caractéres, est exclusivement composé de caractéres alph-numériques et
   doit avoir une valeur contenue dans la base de données. Vérifiez-le bien !
  </para>
 </note>
 <para>
  Assurez-vous de bien passer le même identifiant aux fonctions
  <link linkend="api.is.cached">is_cached()</link> et
  <link linkend="api.clear.cache">clear_cache()</link>.
 </para>
 <example>
  <title>passer un  cache_id a is_cached()</title>
  <programlisting>
<![CDATA[
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$my_cache_id = $_GET['article_id'];

if(!$smarty->is_cached('index.tpl',$my_cache_id)) {
	// pas de fichier de cache dispo, on assigne donc les variables
	$contents = get_database_contents();
	$smarty->assign($contents);
}

$smarty->display('index.tpl',$my_cache_id);
]]>
  </programlisting>
 </example>
 <para>
  Vous pouvez effacer tous les fichiers de cache pour un identifiant
  de cache particulier en passant null en tant que premier paramétre
  a clear_cache().
 </para>
 <example>
  <title>effacement de tous les fichiers de cache pour un identifiant de cache particulier</title>
  <programlisting>
<![CDATA[
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// efface tous les fichiers de cache avec "sports" comme identifiant
$smarty->clear_cache(null,"sports");

$smarty->display('index.tpl',"sports");
]]>
  </programlisting>
 </example>
 <para>
  De cette maniére vous pouvez "grouper" vos fichiers de cache en leur
  donnant le même identifiant.
 </para>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
