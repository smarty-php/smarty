<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
<sect1 id="caching.setting.up">
 <title>Paramétrer le cache</title>
 <para>
  La premiére chose a faire est d'activer le cache. Cela est fait en
  mettant <link linkend="variable.caching">$caching</link> = true
  (ou 1).
 </para>
 <example>
  <title>activation du cache</title>
<programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$smarty->display('index.tpl');</programlisting>
 </example>
 <para>
  Avec le cache activé, la fonction display('index.tpl') va afficher
  le template mais sauvegardera par la même occasion une copie du résultat
  dans un fichier (de cache) du répertoire
  <link linkend="variable.cache.dir">$cache_dir</link>. Au prochain appel de
   display('index.tpl'), le fichier de cache sera préféré a la réutilisation
   du template.
  </para>
  <note>
   <title>Note technique</title>
   <para>
    Les fichiers situés dans $cache_dir sont nommés de la même faton que les templates.
    Bien qu'ils aient une extension ".php", ils ne sont pas vraiment exécutable.
    N'éditez surtout pas ces fichiers !
   </para>
  </note>
  <para>
   Tout fichier de cache a une durée de vie limitée déterminée par <link
   linkend="variable.cache.lifetime">$cache_lifetime</link>. La valeur par
   défaut est 3600 secondes, i.e. 1 heure. Une fois que cette durée est
   dépassée, le cache est regénéré. Il est possible de donner
   une durée d'expiration propre a chaque fichier de cache en réglant
   $caching = 2.
   Se reporter a la documentation de <link
   linkend="variable.cache.lifetime">$cache_lifetime</link> pour plus de
   détails.
  </para>
  <example>
   <title>réglage individuel de cache_lifetime</title>
<programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = 2; // régler la durée de vie individuellement

// régle la durée de vie du cache a 15 minutes pour index.tpl
$smarty->cache_lifetime = 300;
$smarty->display('index.tpl');

// régle la durée de vie du cache a 1 heure pour home.tpl
$smarty->cache_lifetime = 3600;
$smarty->display('home.tpl');

// NOTE : le réglage suivant ne fonctionne pas quand $caching = 2. La durée de vie
// du fichier de cache de home.tpl a déja été réglée a 1 heure et ne respectera
// plus la valeur de $cache_lifetime. Le cache de home.tpl expirera toujours
// dans 1 heure.
$smarty->cache_lifetime = 30; // 30 secondes
$smarty->display('home.tpl');</programlisting>
  </example>
  <para>
   Si <link linkend="variable.compile.check">$compile_check</link> est actif,
   chaque fichier de template et de configuration qui a un rapport
   avec le fichier de cache sera vérifié pour détecter une éventuelle
   modification. Si l'un de ces fichiers a été modifié depuis que le fichier de cache a été
   généré, le cache est immédiatement regénéré. Ce processus est covteux, donc,
   pour des raisons de performances, mettez ce paramétre a false pour une application
   en production.
  </para>
  <example>
   <title>activation de $compile_check</title>
<programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;
$smarty->compile_check = true;

$smarty->display('index.tpl');</programlisting>
  </example>
  <para>
   Si <link linkend="variable.force.compile">$force_compile</link> est actif,
   les fichiers de cache sont toujours regénérés. Ceci revient finalement a
   désactiver le cache. $force_compile est utilisé a des fins de débogage,
   un moyen plus efficace de désactiver le cache est de régler
   <link	linkend="variable.caching">$caching</link> = false (ou 0).
   </para>
   <para>
    La fonction <link linkend="api.is.cached">is_cached()</link> permet
    de tester si un template a ou non un fichier de cache valide.
    Si vous disposez d'un template en cache qui requiert une requête
    a une base de données, vous pouvez utiliser cette méthode plut(t
    que $compile_check.
   </para>
   <example>
    <title>utilisation de is_cached()</title>
<programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

if(!$smarty->is_cached('index.tpl')) {
   // pas de cache disponible, on assigne
	$contents = get_database_contents();
	$smarty->assign($contents);
}

$smarty->display('index.tpl');</programlisting>
   </example>
   <para>
    Vous pouvez rendre dynamiques seulement certaines parties d'une
    page avec la fonction de templates <link
    linkend="language.function.insert">insert</link>.
    Imaginons que toute une page doit être mise en cache a part
    une banniére en bas a droite. En utilisant une fonction insert pour la
    banniére, vous pouvez garder cet élément dynamique dans le contenu qui
    est en cache. Reportez-vous a la documentation
    <link linkend="language.function.insert">insert</link> pour plus de détails
     et des exemples.
    </para>
    <para>
     Vous pouvez effacer tous les fichiers du cache avec la fonction <link
     linkend="api.clear.all.cache">clear_all_cache(),</link> ou de faton
     individuelle (ou par groupe) avec la fonction <link
     linkend="api.clear.cache">clear_cache()</link>.
    </para>
    <example>
     <title>nettoyage du cache</title>
<programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// efface tous les fichiers du cache
$smarty->clear_all_cache();

// efface le fichier de cache du template 'index.tpl'
$smarty->clear_cache('index.tpl');

$smarty->display('index.tpl');</programlisting>
    </example>
   </sect1>
   <!-- Keep this comment at the end of the file
   Local variables:
   mode: sgml
   sgml-omittag:t
   sgml-shorttag:t
   sgml-minimize-attributes:nil
   sgml-always-quote-attributes:t
   sgml-indent-step:1
   sgml-indent-data:t
   indent-tabs-mode:nil
   sgml-parent-document:nil
   sgml-default-dtd-file:"../../../../manual.ced"
   sgml-exposed-tags:nil
   sgml-local-catalogs:nil
   sgml-local-ecat-files:nil
   End:
   vim600: syn=xml fen fdm=syntax fdl=2 si
   vim: et tw=78 syn=sgml
   vi: ts=1 sw=1
   -->
