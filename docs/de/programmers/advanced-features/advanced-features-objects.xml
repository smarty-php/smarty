<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
   <sect1 id="advanced.features.objects">
    <title>Objekte</title>
    <para>
     Smarty erlaubt es, auf PHP Objekt durch das Template zuzugreifen. Daf&uuml;r gibt es
     zwei Wege. Der erste ist, Objekte zu registrieren und wie auf eine eigene Funktion zuzugreifen.
     Der andere Weg ist, das Objekt dem Template zuzuweisen und darauf wie auf andere Variablen
     zuzugreifen. Die erste Methode hat eine nettere Template Syntax und ist sicherer da der Zugriff
     auf ein registriertes Objekt mit Sicherheitseinstellungen kontrolliert werden kann. Der Nachteil
     ist, dass registrierte Objekte nicht in Loops verwendet werden k&ouml;nnen. Welchen Weg Sie einschlagen
     wird von Ihren Bed&uuml;rfnissen definiert, die erste Methode ist jedoch zu bevorzugen.
    </para>
    <para>
    Wenn die Sicherheitsfunktionen eingeschaltet sind, k&ouml;nnen keine private Methoden (solche die einen '_'-Prefix tragen)
    aufgerufen werden. Wenn eine Methode und eine Eigeschaft mit dem gleichen Namen existieren wird die Methode
    verwendet.
    </para>
    <para>
    Sie k&ouml;nnen den Zugriff auf Methoden und Eigenschaften einschr&auml;nken
    indem Sie sie als Array als dritten Registrationsparameter &uuml;bergeben.
    </para>
    <para>
    Normalerweise werden Parameter welche einem Objekt via Template &uuml;bergeben
    werden genau so &uuml;bergeben wie dies bei normalen eigenen Funktionen der Fall ist.
    Das erste Objekt ist ein assoziatives Array und das zweite das Smarty Objekt selbst.
    Wenn Sie die Parameter einzeln erhalten m&ouml;chten k&ouml;nnen Sie den vierten
    Parameter auf FALSE setzen.
    </para>
    <para>
    Der optionale f&uuml;nfte Parameter hat nur einen Effekt wenn 
    <parameter>format</parameter> = <literal>true</literal> ist und eine Liste von
    Methoden enth&auml;lt die als Block verarbeitet werden sollen.
    Das bedeutet, dass solche Methoden ein schliessendes Tag im Template
    enthalten m&uuml;ssen (<literal>{foobar->meth2}...{/foobar->meth2}</literal>)
    und die Parameter zu den Funktionen die selbe Syntax haben wie block-function-plugins:
    sie erhalten also die 4 Parameter
    <parameter>$params</parameter>,
    <parameter>$content</parameter>,
    <parameter>&amp;$smarty</parameter> und
    <parameter>&amp;$repeat</parameter>,
    und verhalten sich auch sonst wie block-function-plugins.
    </para>
    <example>
     <title>registierte oder zugewiesene Objekte verwenden</title>
     <programlisting>
&lt;?php
// das objekt

class My_Object {
        function meth1($params, &amp;$smarty_obj) {
                return "meine meth1";
        }
}

$myobj = new My_Object;
// objekt registrieren (referenz)
$smarty->register_object("foobar",$myobj);
// zugriff auf methoden und eigeschaften einschr&auml;nken
$smarty->register_object("foobar",$myobj,array('meth1','meth2','prop1'));
// wenn wir das traditionelle parameter format verwenden wollen, &uuml;bergeben wir false f&uuml;r den parameter format
$smarty->register_object("foobar",$myobj,null,false);

// objekte zuweisen (auch via referenz m&ouml;glich)
$smarty->assign_by_ref("myobj", $myobj);

$smarty->display("index.tpl");
?&gt;

TEMPLATE:

{* zugriff auf ein registriertes objekt *}
{foobar->meth1 p1="foo" p2=$bar}

{* ausgabe zuweisen *}
{foobar->meth1 p1="foo" p2=$bar assign="output"}
ausgabe war: {$output}

{* auf unser zugewiesenes objekt zugreiffen *}
{$myobj->meth1("foo",$bar)}</programlisting>
    </example>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->