<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
 <chapter id="plugins">
  <title>Extending Smarty With Plugins</title>
  <para>
   Version 2.0 introduced the plugin architecture that is used
   for almost all the customizable functionality of Smarty. This includes:
   <itemizedlist spacing="compact">
    <listitem><simpara>functions</simpara></listitem>
    <listitem><simpara>modifiers</simpara></listitem>
    <listitem><simpara>block functions</simpara></listitem>
    <listitem><simpara>compiler functions</simpara></listitem>
    <listitem><simpara>prefilters</simpara></listitem>
    <listitem><simpara>postfilters</simpara></listitem>
    <listitem><simpara>outputfilters</simpara></listitem>
    <listitem><simpara>resources</simpara></listitem>
    <listitem><simpara>inserts</simpara></listitem>
   </itemizedlist>
   With the exception of resources, backwards compatibility with the old
   way of registering handler functions via register_* API is preserved. If
   you did not use the API but instead modified the class variables
   <literal>$custom_funcs</literal>, <literal>$custom_mods</literal>, and
   other ones directly, then you will need to adjust your scripts to either
   use the API or convert your custom functionality into plugins.
  </para>
   
  <sect1>
   <title>How Plugins Work</title>
   <para>
    Plugins are always loaded on demand. Only the specific modifiers,
    functions, resources, etc invoked in the templates scripts will be
    loaded. Moreover, each plugin is loaded only once, even if you have
    several different instances of Smarty running within the same request.
   </para>
   <para>
    Pre/postfilters and output filters are a bit of a special case. Since
    they are not mentioned in the templates, they must be registered or
    loaded explicitly via API functions before the template is processed.
    The order in which multiple filters of the same type are executed
    depends on the order in which they are registered or loaded.
   </para>
   <para>
    The <link linkend="variable.plugins.dir">plugins directory</link>
    can be a string containing a path or an array containing multiple
    paths. To install a plugin, simply place it in one of the
    directories and Smarty will use it automatically.
   </para>
  </sect1>

   <sect1 id="plugins.naming.conventions">
    <title>Naming Conventions</title>
    <para>
     Plugin files and functions must follow a very specific naming
     convention in order to be located by Smarty.
    </para>
    <para>
     The plugin files must be named as follows:
     <blockquote>
      <para>
       <filename>
        <replaceable>type</replaceable>.<replaceable>name</replaceable>.php
       </filename>
      </para>
     </blockquote>
    </para>
    <para>
     Where <literal>type</literal> is one of these plugin types:
     <itemizedlist spacing="compact">
      <listitem><simpara>function</simpara></listitem>
      <listitem><simpara>modifier</simpara></listitem>
      <listitem><simpara>block</simpara></listitem>
      <listitem><simpara>compiler</simpara></listitem>
      <listitem><simpara>prefilter</simpara></listitem>
      <listitem><simpara>postfilter</simpara></listitem>
      <listitem><simpara>outputfilter</simpara></listitem>
      <listitem><simpara>resource</simpara></listitem>
      <listitem><simpara>insert</simpara></listitem>
     </itemizedlist>
    </para>
    <para>
     And <literal>name</literal> should be a valid identifier (letters,
     numbers, and underscores only).
    </para>
    <para>
     Some examples: <literal>function.html_select_date.php</literal>,
     <literal>resource.db.php</literal>,
     <literal>modifier.spacify.php</literal>.
    </para>
    <para>
     The plugin functions inside the plugin files must be named as follows:
     <blockquote>
      <para>
       <function>smarty_<replaceable>type</replaceable>_<replaceable>name</replaceable></function>
      </para>
     </blockquote>
    </para>
    <para>
     The meanings of <literal>type</literal> and <literal>name</literal> are
     the same as before.
    </para>
    <para>
     Smarty will output appropriate error messages if the plugin file it
     needs is not found, or if the file or the plugin function are named
     improperly.
    </para>
   </sect1>

   <sect1 id="plugins.writing">
    <title>Writing Plugins</title>
    <para>
     Plugins can be either loaded by Smarty automatically from the
     filesystem or they can be registered at runtime via one of the
     register_* API functions. They can also be unregistered by using
     unregister_* API functions.
    </para>
    <para>
     For the plugins that are registered at runtime, the name of the plugin
     function(s) does not have to follow the naming convention.
    </para>
    <para>
     If a plugin depends on some functionality provided by another plugin
     (as is the case with some plugins bundled with Smarty), then the proper
     way to load the needed plugin is this:
    </para>
    <programlisting role="php">
<![CDATA[
<?php
require_once $smarty->_get_plugin_filepath('function', 'html_options');
?>
]]>
    </programlisting>
    <para>
     As a general rule, Smarty object is always passed to the plugins
     as the last parameter (with two exceptions: modifiers do not get
     passed the Smarty object at all and blocks get passed
     <parameter>&amp;$repeat</parameter> after the Smarty object to keep
     backwards compatibility to older versions of Smarty).
    </para>
   </sect1>

   <sect1 id="plugins.functions"><title>Template Functions</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_function_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     All attributes passed to template functions from the template are
     contained in the <parameter>$params</parameter> as an associative
     array.
    </para>
    <para>
	 The output (return value) of the function will be substituted in place of the
     function tag in the template (<function>fetch</function> function, for
     example). Alternatively, the function can simply perform some other
     task without any output (<function>assign</function> function).
    </para>
    <para>
     If the function needs to assign some variables to the template or use
     some other Smarty-provided functionality, it can use the supplied
     <parameter>$smarty</parameter> object to do so.
    </para>
    <para>
     See also:
     <link linkend="api.register.function">register_function()</link>,
     <link linkend="api.unregister.function">unregister_function()</link>.
    </para>
    <para>
     <example>
      <title>function plugin with output</title>
      <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     function.eightball.php
 * Type:     function
 * Name:     eightball
 * Purpose:  outputs a random magic answer
 * -------------------------------------------------------------
 */
function smarty_function_eightball($params, &amp;$smarty)
{
    $answers = array('Yes',
                     'No',
                     'No way',
                     'Outlook not so good',
                     'Ask again soon',
                     'Maybe in your reality');

    $result = array_rand($answers);
    return $answers[$result];
}
?>
]]>
</programlisting>
     </example>
    </para>
    <para>
     which can be used in the template as:
    </para>
    <programlisting>
Question: Will we ever have time travel?
Answer: {eightball}.
    </programlisting>
    <para>
     <example>
      <title>function plugin without output</title>
      <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     function.assign.php
 * Type:     function
 * Name:     assign
 * Purpose:  assign a value to a template variable
 * -------------------------------------------------------------
 */
function smarty_function_assign($params, &amp;$smarty)
{
    if (empty($params['var'])) {
        $smarty->trigger_error("assign: missing 'var' parameter");
        return;
    }

    if (!in_array('value', array_keys($params))) {
        $smarty->trigger_error("assign: missing 'value' parameter");
        return;
    }

    $smarty->assign($params['var'], $params['value']);
}
?>
]]>
</programlisting>
     </example>
    </para>
   </sect1>

   <sect1 id="plugins.modifiers"><title>Modifiers</title>
    <para>
     Modifiers are little functions that are applied to a variable in the
     template before it is displayed or used in some other context.
     Modifiers can be chained together.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_modifier_<replaceable>name</replaceable></function></funcdef>
      <paramdef>mixed <parameter>$value</parameter></paramdef>
      <paramdef>[mixed <parameter>$param1</parameter>, ...]</paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     The first parameter to the modifier plugin is the value on which
     the modifier is supposed to operate. The rest of the parameters can be
     optional, depending on what kind of operation is supposed to be
     performed.
    </para>
    <para>
     The modifier has to return the result of its processing.
    </para>
    <para>
     See also
     <link linkend="api.register.modifier">register_modifier()</link>,
     <link linkend="api.unregister.modifier">unregister_modifier()</link>.
    </para>
    <example>
     <title>simple modifier plugin</title>
     <para>
      This plugin basically aliases one of the built-in PHP functions. It
      does not have any additional parameters.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     modifier.capitalize.php
 * Type:     modifier
 * Name:     capitalize
 * Purpose:  capitalize words in the string
 * -------------------------------------------------------------
 */
function smarty_modifier_capitalize($string)
{
    return ucwords($string);
}
?>
]]>
</programlisting>
    </example>
    <para></para>
    <example>
     <title>more complex modifier plugin</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     modifier.truncate.php
 * Type:     modifier
 * Name:     truncate
 * Purpose:  Truncate a string to a certain length if necessary,
 *           optionally splitting in the middle of a word, and 
 *           appending the $etc string.
 * -------------------------------------------------------------
 */
function smarty_modifier_truncate($string, $length = 80, $etc = '...',
                                  $break_words = false)
{
    if ($length == 0)
        return '';

    if (strlen($string) > $length) {
        $length -= strlen($etc);
        $fragment = substr($string, 0, $length+1);
        if ($break_words)
            $fragment = substr($fragment, 0, -1);
        else
            $fragment = preg_replace('/\s+(\S+)?$/', '', $fragment);
        return $fragment.$etc;
    } else
        return $string;
}
?>
]]>
</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.block.functions"><title>Block Functions</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_block_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>mixed <parameter>$content</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Block functions are functions of the form: {func} .. {/func}. In other
     words, they enclose a template block and operate on the contents of
     this block. Block functions take precedence over custom functions of
     the same name, that is, you cannot have both custom function {func} and
     block function {func} .. {/func}.
    </para>
    <para>
     By default your function implementation is called twice by
     Smarty: once for the opening tag, and once for the closing tag
     (see <literal>&amp;$repeat</literal> below how to change this).
    </para>
    <para>
     Only the opening tag of the block function may have attributes. All
     attributes passed to template functions from the template are contained
     in the <parameter>$params</parameter> as an associative array. You can
     access those values as e.g. <varname>$params['start']</varname>.
     The opening tag attributes are also accessible to your function
     when processing the closing tag.
    </para>
    <para>
     The value of <parameter>$content</parameter> variable depends on
     whether your function is called for the opening or closing tag. In case
     of the opening tag, it will be <literal>null</literal>, and in case of
     the closing tag it will be the contents of the template block.
     Note that the template block will have already been processed by
     Smarty, so all you will receive is the template output, not the
     template source.
    </para>

    <para>
     The parameter <parameter>&amp;$repeat</parameter> is passed by
     reference to the function implementation and provides a
     possibility for it to control how many times the block is
     displayed. By default <parameter>$repeat</parameter> is
     <literal>true</literal> at the first call of the block-function
     (the block opening tag) and <literal>false</literal> on all
     subsequent calls to the block function (the block's closing tag).
     Each time the function implementation returns with
     <parameter>&amp;$repeat</parameter> being true, the contents between
     {func} .. {/func} are evaluated and the function implementation
     is called again with the new block contents in the parameter
     <parameter>$content</parameter>.

	</para>

    <para>
     If you have nested block functions, it's possible to find out what the
     parent block function is by accessing
     <varname>$smarty->_tag_stack</varname> variable. Just do a var_dump()
     on it and the structure should be apparent.
    </para>
    <para>
     See also:
     <link linkend="api.register.block">register_block()</link>,
     <link linkend="api.unregister.block">unregister_block()</link>.
    </para>
    <example>
     <title>block function</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     block.translate.php
 * Type:     block
 * Name:     translate
 * Purpose:  translate a block of text
 * -------------------------------------------------------------
 */
function smarty_block_translate($params, $content, &amp;$smarty)
{
    if (isset($content)) {
        $lang = $params['lang'];
        // do some intelligent translation thing here with $content
        return $translation;
    }
}
?>
]]>
</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.compiler.functions"><title>Compiler Functions</title>
    <para>
     Compiler functions are called only during compilation of the template.
     They are useful for injecting PHP code or time-sensitive static
     content into the template. If there is both a compiler function and a
     custom function registered under the same name, the compiler function
     has precedence.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_compiler_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$tag_arg</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     The compiler function is passed two parameters: the tag argument
     string - basically, everything from the function name until the ending
     delimiter, and the Smarty object. It's supposed to return the PHP code
     to be injected into the compiled template.
    </para>
    <para>
     See also
     <link linkend="api.register.compiler.function">register_compiler_function()</link>,
     <link linkend="api.unregister.compiler.function">unregister_compiler_function()</link>.
    </para>
    <example>
     <title>simple compiler function</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     compiler.tplheader.php
 * Type:     compiler
 * Name:     tplheader
 * Purpose:  Output header containing the source file name and
 *           the time it was compiled.
 * -------------------------------------------------------------
 */
function smarty_compiler_tplheader($tag_arg, &amp;$smarty)
{
    return "\necho '" . $smarty->_current_file . " compiled at " . date('Y-m-d H:M'). "';";
}
?>
]]>
</programlisting>
     <para>
      This function can be called from the template as:
     </para>
     <programlisting>
{* this function gets executed at compile time only *}
{tplheader}
     </programlisting>
     <para>
      The resulting PHP code in the compiled template would be something like this:
     </para>
     <programlisting role="php">
<![CDATA[
<?php
echo 'index.tpl compiled at 2002-02-20 20:02';
?>
]]>
</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.prefilters.postfilters">
    <title>Prefilters/Postfilters</title>
    <para>
     Prefilter and postfilter plugins are very similar in concept; where
     they differ is in the execution -- more precisely the time of their
     execution.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_prefilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Prefilters are used to process the source of the template immediately
     before compilation. The first parameter to the prefilter function is
     the template source, possibly modified by some other prefilters. The
     plugin is supposed to return the modified source.  Note that this
     source is not saved anywhere, it is only used for compilation.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_postfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$compiled</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Postfilters are used to process the compiled output of the template
     (the PHP code) immediately after the compilation is done but before the
     compiled template is saved to the filesystem. The first parameter to
     the postfilter function is the compiled template code, possibly
     modified by other postfilters. The plugin is supposed to return the
     modified version of this code.
    </para>
    <example>
     <title>prefilter plugin</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     prefilter.pre01.php
 * Type:     prefilter
 * Name:     pre01
 * Purpose:  Convert html tags to be lowercase.
 * -------------------------------------------------------------
 */
 function smarty_prefilter_pre01($source, &amp;$smarty)
 {
     return preg_replace('!<(\w+)[^>]+>!e', 'strtolower("$1")', $source);
 }
?>
]]>
</programlisting>
    </example>
    <para></para>
    <example>
     <title>postfilter plugin</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     postfilter.post01.php
 * Type:     postfilter
 * Name:     post01
 * Purpose:  Output code that lists all current template vars.
 * -------------------------------------------------------------
 */
 function smarty_postfilter_post01($compiled, &amp;$smarty)
 {
     $compiled = "<pre>\n<?php print_r(\$this->get_template_vars()); ?>\n</pre>" . $compiled;
     return $compiled;
 }
?>
]]>
</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.outputfilters"><title>Output Filters</title>
    <para>
     Output filter plugins operate on a template's output, after the
     template is loaded and executed, but before the output is displayed.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_outputfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$template_output</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     The first parameter to the output filter function is the template
     output that needs to be processed, and the second parameter is the
     instance of Smarty invoking the plugin. The plugin is supposed to do
     the processing and return the results.
    </para>
    <example>
     <title>output filter plugin</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * File:     outputfilter.protect_email.php
 * Type:     outputfilter
 * Name:     protect_email
 * Purpose:  Converts @ sign in email addresses to %40 as 
 *           a simple protection against spambots
 * -------------------------------------------------------------
 */
 function smarty_outputfilter_protect_email($output, &amp;$smarty)
 {
     return preg_replace('!(\S+)@([a-zA-Z0-9\.\-]+\.([a-zA-Z]{2,3}|[0-9]{1,3}))!',
                         '$1%40$2', $output);
 }
?>
]]>
     </programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.resources"><title>Resources</title>
    <para>
     Resource plugins are meant as a generic way of providing template
     sources or PHP script components to Smarty. Some examples of resources:
     databases, LDAP, shared memory, sockets, and so on.
    </para>

    <para>
     There are a total of 4 functions that need to be registered for each
     type of resource. Every function will receive the requested resource as
     the first parameter and the Smarty object as the last parameter. The
     rest of parameters depend on the function.
    </para>

    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_source</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>string <parameter>&amp;$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_timestamp</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>int <parameter>&amp;$timestamp</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_secure</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_trusted</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>

    <para>
     The first function is supposed to retrieve the resource. Its second
     parameter is a variable passed by reference where the result should be
     stored. The function is supposed to return <literal>true</literal> if
     it was able to successfully retrieve the resource and
     <literal>false</literal> otherwise.
    </para>

    <para>
     The second function is supposed to retrieve the last modification time
     of the requested resource (as a UNIX timestamp). The second parameter
     is a variable passed by reference where the timestamp should be stored.
     The function is supposed to return <literal>true</literal> if the
     timestamp could be succesfully determined, and <literal>false</literal>
     otherwise.
    </para>

    <para>
     The third function is supposed to return <literal>true</literal> or
     <literal>false</literal>, depending on whether the requested resource
     is secure or not. This function is used only for template resources but
     should still be defined.
    </para>

    <para>
     The fourth function is supposed to return <literal>true</literal> or
     <literal>false</literal>, depending on whether the requested resource
     is trusted or not. This function is used for only for PHP script
     components requested by <command>include_php</command> tag or
     <command>insert</command> tag with <structfield>src</structfield>
     attribute. However, it should still be defined even for template
     resources.
    </para>
    <para>
     See also
     <link linkend="api.register.resource">register_resource()</link>,
     <link linkend="api.unregister.resource">unregister_resource()</link>.
    </para>
    <example>
     <title>resource plugin</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * File:     resource.db.php
 * Type:     resource
 * Name:     db
 * Purpose:  Fetches templates from a database
 * -------------------------------------------------------------
 */
function smarty_resource_db_source($tpl_name, &amp;$tpl_source, &amp;$smarty)
{
    // do database call here to fetch your template,
    // populating $tpl_source
    $sql = new SQL;
    $sql->query("select tpl_source
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_source = $sql->record['tpl_source'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_timestamp($tpl_name, &amp;$tpl_timestamp, &amp;$smarty)
{
    // do database call here to populate $tpl_timestamp.
    $sql = new SQL;
    $sql->query("select tpl_timestamp
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_timestamp = $sql->record['tpl_timestamp'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_secure($tpl_name, &amp;$smarty)
{
    // assume all templates are secure
    return true;
}

function smarty_resource_db_trusted($tpl_name, &amp;$smarty)
{
    // not used for templates
}
?>
]]>
</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.inserts"><title>Inserts</title>
    <para>
     Insert plugins are used to implement functions that are invoked by
     <link linkend="language.function.insert"><command>insert</command></link>
     tags in the template.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_insert_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     The first parameter to the function is an associative array of
     attributes passed to the insert.
    </para>
    <para>
     The insert function is supposed to return the result which will be
     substituted in place of the <command>insert</command> tag in the
     template.
    </para>
    <example>
     <title>insert plugin</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * File:     insert.time.php
 * Type:     time
 * Name:     time
 * Purpose:  Inserts current date/time according to format
 * -------------------------------------------------------------
 */
function smarty_insert_time($params, &amp;$smarty)
{
    if (empty($params['format'])) {
        $smarty->trigger_error("insert time: missing 'format' parameter");
        return;
    }

    $datetime = strftime($params['format']);
    return $datetime;
}
?>
]]>
</programlisting>
    </example>
   </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
