<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
   <chapter id="api.functions">
     <title>Métodos</title>
        <sect1 id="api.append">
         <title>append</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
           <paramdef>boolean <parameter>merge</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
		  Isso é usado para adicionar um elemento para um array fixado. Se você adicionar
		  uma string como valor, isso irá converter-se para um valor de array e então adicioná-lo.
		  Você pode explicitamente passar pares nomes/valores, ou arrays associativos
		  contendo o par nome/valor. Se você passar o terceiro parâmetro opcional para true,
		  o valor unir-se ao array atual
		  ao invés de ser adicionado.
         </para>
		 <note>
		 <title>Notas Técnicas</title>
		 <para>
		 O parâmetro de união respeita a chave do array, então se você
		 mesclar dois índices númericos de um array, eles devem sobrescrever-se
		 um ao outro ou em resultados não sequências de chave. Isso é diferente da função de PHP array_merge() 
		 que apaga as chaves e as renumera.
		 </para>
		 </note>
         <example>
          <title>append</title>
          <programlisting>
// passing name/value pairs
$smarty->append("Name","Fred");
$smarty->append("Address",$address);

// passing an associative array
$smarty->append(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.append.by.ref">
      <title>append_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
        <paramdef>boolean <parameter>merge</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
	   Isso é usado para adicionar vlaores para o template por referência.
	   Se você adicionar uma variável por referência e então alterar este valor
	   o valor adicionado enxergará a alteração também. Para objetos,
	   append_by_ref() também evita uma cópia em memória do objeto adicionado. 
	   Veja o manual do PHP em referenciando variáveis para uma melhor explanação sobre o assunto.
	   Se você passar o terceiro parâmetro opcional para true,
	   o valor irá ser mesclado com o array atual ao invés de adicioná-lo.   
      </para>
	  <note>
	  <title>Notas Técnicas</title>
	  <para>
	  O parâmetro de união respeita a chave do array, então se você mesclar
	  dois índices númericos de arrays, eles devem sobrescrever-se um ao outro ou
	  em resultados não sequências de chave. Isso é diferente da função de PHP array_merge()
	  que apaga as chaves numéricas e as renumera.
	  </para>
	  </note>
      <example>
       <title>append_by_ref</title>
       <programlisting>
// appending name/value pairs
$smarty->append_by_ref("Name",$myname);
$smarty->append_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign">
      <title>assign</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
       Isso é usado para fixar valores para o template. Você pode
       explicitamente passar pares de nomes/valores, ou um array associativo
       contendo o par de nome/valor. 
      </para>
      <example>
       <title>assign</title>
       <programlisting>
// passing name/value pairs
$smarty->assign("Name","Fred");
$smarty->assign("Address",$address);

// passing an associative array
$smarty->assign(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign.by.ref">
      <title>assign_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
	   Isso é usado para fixar valores para o template por referência ao invés de fazer uma cópia.
	   Veja o manual do PHP na parte sobre referência de variáveis para uma explanação mais detalhada.
      </para>
	  <note>
	  <title>Notas Técnicas</title>
	  <para>
	   Isso é usado para fixar valores para o template por referência.
	   Se você fixar uma variável por referência e então alterar o valor dela,
	   o valor fixado enxergará o valor alterado também.
	   Para objetos, assign_by_ref() também restringe uma cópia de objetos fixados
	   em memória.
	   Veja o manual do php em refereciando variáveis para uma melhor explanação.   
	  </para>
	  </note>
      <example>
       <title>assign_by_ref</title>
       <programlisting>
// passing name/value pairs
$smarty->assign_by_ref("Name",$myname);
$smarty->assign_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.assign">
			<title>clear_all_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_assign</function></funcdef>
				<paramdef><parameter></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				Isso limpa o valor de todas as variáveis fixadas.
			</para>
<example>
<title>clear_all_assign</title>
<programlisting>
// clear all assigned variables
$smarty->clear_all_assign();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.cache">
			<title>clear_all_cache</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_cache</function></funcdef>
				<paramdef>int <parameter>expire time</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				Isso limpa completamente o cache de template. Como um parâmetro 
				opcional, você pode fornecer um ano mínimo em segundos
			        que o arquivo de cache deve ter antes deles serem apagados. 
			</para>
<example>
<title>clear_all_cache</title>
<programlisting>
// clear the entire cache
$smarty->clear_all_cache();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.assign">
			<title>clear_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_assign</function></funcdef>
				<paramdef>string <parameter>var</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				Isso limpa o valor de uma variável fixada. Isso
				pode ser um valor simples, ou um array de valores.
			</para>
<example>
<title>clear_assign</title>
<programlisting>
// clear a single variable
$smarty->clear_assign("Name");

// clear multiple variables
$smarty->clear_assign(array("Name","Address","Zip"));</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.cache">
			<title>clear_cache</title>
   <methodsynopsis>
   <type>void</type><methodname>clear_cache</methodname>
    <methodparam choice="opt"><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>expire time</parameter></methodparam>
   </methodsynopsis>
			<para>
				Isso limpa o cache de um template específico. Se você tem
				múltiplos caches para este arquivo, você limpa o cache
				específico fornecendo o cache id como o segundo parâmetro.
				Você pode também passar um compile id como um terceiro parâmetro.
				Você pode "agrupar" templates juntos e então eles podem ser removidos
				como um grupo. Veja o <link linkend="caching">caching section</link> para maiores informações. Como um quarto
				parâmetro opcional, você pode fornecer um ano mínimo em segundos 
				que o arquivo de cache deve
				ter antes dele ser apagado.
			</para>
<example>
<title>clear_cache</title>
<programlisting>
// clear the cache for a template
$smarty->clear_cache("index.tpl");

// clear the cache for a particular cache id in an multiple-cache template
$smarty->clear_cache("index.tpl","CACHEID");</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.compiled.tpl">
			<title>clear_compiled_tpl</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_compiled_tpl</function></funcdef>
				<paramdef>string <parameter>tpl_file</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Isso limpa a versão compilada do recurso de template especificado,
			ou todos os arquivos de templates compilados se nenhum for especificado.
			Essa função é para uso avançado somente, não normalmente necessária.
			</para>
<example>
<title>clear_compiled_tpl</title>
<programlisting>
// clear a specific template resource
$smarty->clear_compiled_tpl("index.tpl");

// clear entire compile directory
$smarty->clear_compiled_tpl();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.config">
			<title>clear_config</title>
   <methodsynopsis>
   <type>void</type><methodname>clear_config</methodname>
    <methodparam choice="opt"><type>string</type><parameter>var</parameter></methodparam>
   </methodsynopsis>

			<para>
			Isso limpa todas as variáveis de configuração fixadas. Se um nome de variável
			é fornecido, somente esta variável é apagada.
			</para>
<example>
<title>clear_config</title>
<programlisting>
// clear all assigned config variables.
$smarty->clear_config();

// clear one variable
$smarty->clear_config('foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.config.load">
			<title>config_load</title>
   <methodsynopsis>
   <type>void</type><methodname>config_load</methodname>
    <methodparam><type>string</type><parameter>file</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>section</parameter></methodparam>
   </methodsynopsis>
			<para>
			Isso carrega o arquivo de configuração de dados e fixa-o para o 
			template. Isso funciona idêntico a função <link
			linkend="language.function.config.load">
			config_load</link>.
			</para>
		  <note>
		  <title>Notas Técnicas</title>
    	  <para>
		   À partir da Smarty 2.4.0, variáveis de template fixadas são
		   mantidas através de fetch() e display(). Variáveis de configuração carregadas
		   de config_load() são sempre de escopo global. Arquivos de configuração
		   também são compilados para execução rápida, e repeita o <link
		   linkend="variable.force.compile">force_compile</link> e <link
		   linkend="variable.compile.check">compile_check</link> parâmetros de configuração.
    	  </para>
		  </note>
<example>
<title>config_load</title>
<programlisting>
// load config variables and assign them
$smarty->config_load('my.conf');

// load a section
$smarty->config_load('my.conf','foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.display">
			<title>display</title>
   <methodsynopsis>
   <type>void</type><methodname>display</methodname>
    <methodparam><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
   </methodsynopsis>
			<para>
                Isso mostra o template. Fornecendo um válido <link
                linkend="template.resources">template resource</link>
                tipo e path. Como um segundo parâmetro opcional, você pode passar
		um cache id. Veja o <link linkend="caching">caching
                section</link> para maiores informações.
			</para>
			<para>
				Como um terceiro parâmetro opcional, você pode passar um compile id.
				Isso está no evento que você quer compilar diferentes versões do
				mesmo template, como ter templates compilados separadamente para diferentes linguagens.
				Outro uso para compile_id é quando você usa mais do que um $template_dir
				mas somente um $compile_dir. Seta um compile_id em separado para cada $template_dir,
				de outra maneira templates com mesmo nome irão sobrescrever-se um ao outro.
				Você pode também setar a variável <link
				linkend="variable.compile.id">$compile_id</link> ao invés de 
				passar isso para cada chamada
				de display().
			</para>	
<example>
<title>display</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;
$smarty->caching = true;

// only do db calls if cache doesn't exist
if(!$smarty->is_cached("index.tpl"))
{

    // dummy up some data
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// display the output
$smarty->display("index.tpl");</programlisting>
</example>
			<para>
			Use a sintaxe para <link
			linkend="template.resources">template resources</link> para
			mostrar arquivos fora do  $template_dir directory.
			</para>
<example>
<title>Exemplos de recursos da função display</title>
<programlisting>
// absolute filepath
$smarty->display("/usr/local/include/templates/header.tpl");

// absolute filepath (same thing)
$smarty->display("file:/usr/local/include/templates/header.tpl");

// windows absolute filepath (MUST use "file:" prefix)
$smarty->display("file:C:/www/pub/templates/header.tpl");

// include from template resource named "db"
$smarty->display("db:header.tpl");</programlisting>
</example>

		</sect1>
		<sect1 id="api.fetch">
			<title>fetch</title>
   <methodsynopsis>
   <type>string</type><methodname>fetch</methodname>
    <methodparam><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
   </methodsynopsis>
			<para>
                Isso retorna a saída do template ao invés de mostrá-lo.
		Fornecendo um tipo ou path válido  <link
                linkend="template.resources">template resource</link>. 
		Como um segundo parâmetro opcional, você pode passar o cache id.
		Veja o <link linkend="caching">caching
                section</link> para maiores informações.
			</para>
			<para>
				Como um terceiro parâmetro opcional, você pode passar um compile id.
				Isso está no evento que você quer compilar diferentes versões do
				mesmo template, como ter templates compilados separadamente para
				diferentes linguagens. Outro uso para compile_id é quando você
				usa mais do que um $template_dir mas somente um $compile_dir. Seta
				um compile_id em separado para cada $template_dir, de outra maneira
				templates com mesmo nome irão sobrescrever-se uns aos outros. Você
				pode também setar a variável <link
				linkend="variable.compile.id">$compile_id</link> ao invés
				de passá-la para cada chamada de fetch().
			</para>
<example>
<title>fetch</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;

$smarty->caching = true;

// only do db calls if cache doesn't exist
if(!$smarty->is_cached("index.tpl"))
{

    // dummy up some data
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// capture the output
$output = $smarty->fetch("index.tpl");

// do something with $output here

echo $output;</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.config.vars">
			<title>get_config_vars</title>
   <methodsynopsis>
   <type>array</type><methodname>get_config_vars</methodname>
    <methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
   </methodsynopsis>
			<para>
				Isso retorna o valor da variável de configuração dada.
				Se nenhum parâmetro é dado, um array de todas as variáveis dos arquivos de configurações é retornado.
			</para>
<example>
<title>get_config_vars</title>
<programlisting>
// get loaded config template var 'foo'
$foo = $smarty->get_config_vars('foo');

// get all loaded config template vars
$config_vars = $smarty->get_config_vars();

// take a look at them
print_r($config_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.registered.object">
			<title>get_registered_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_registered_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				Isso retorna uma referência para um objeto registrado.
				Isso é útil para dentro de uma função customizada quando você
				precisa acessar diretamente um objeto registrado.
			</para>
<example>
<title>get_registered_object</title>
<programlisting>
function smarty_block_foo($params, &amp;$smarty) {
	if (isset[$params['object']]) {
		// get reference to registered object
   		$obj_ref =&amp; $smarty->&amp;get_registered_object($params['object']);
		// use $obj_ref is now a reference to the object
	}
}</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.template.vars">
			<title>get_template_vars</title>
   <methodsynopsis>
   <type>array</type><methodname>get_template_vars</methodname>
    <methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
   </methodsynopsis>
			<para>
				Isso retorna o valor de uma variável fixada. Se nenhum parâmetro
				é dado, um array de todas as variávels fixadas é retornado.
			</para>
<example>
<title>get_template_vars</title>
<programlisting>
// get assigned template var 'foo'
$foo = $smarty->get_template_vars('foo');

// get all assigned template vars
$tpl_vars = $smarty->get_template_vars();

// take a look at them
print_r($tpl_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.is.cached">
			<title>is_cached</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>is_cached</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>[string <parameter>cache_id</parameter>]</paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Isso retorna true se há um cache válido para esse template.
		Isso somente funciona se <link
                linkend="variable.caching">caching</link> está setado para true.
			</para>
<example>
<title>is_cached</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl")) {
    // do database calls, assign vars here
}

$smarty->display("index.tpl");</programlisting>
</example>
            <para>
                Você pode também passar um cache id como um segundo parâmetro opcional
		no caso você quer múltiplos caches para o template dado.
            </para>
<example>
<title>is_cached with multiple-cache template</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl","FrontPage")) {
    // do database calls, assign vars here
}

$smarty->display("index.tpl","FrontPage");</programlisting>
</example>
		</sect1>
        <sect1 id="api.load.filter">
         <title>load_filter</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>load_filter</function></funcdef>
           <paramdef>string <parameter>type</parameter></paramdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Essa função pode ser usada para carregar um filtro de plugin. O primeiro
	  argumento especifica o tipo do filtro para carregar e pode ser um
	  dos seguintes: 'pre', 'post', ou 'output'. O segundo argumento
	  especifica o nome do filtro de plugin, por exemplo, 'trim'.
         </para>
<example>
<title>Carregando filtros de plugins</title>
<programlisting>
$smarty->load_filter('pre', 'trim'); // load prefilter named 'trim'
$smarty->load_filter('pre', 'datefooter'); // load another prefilter named 'datefooter'
$smarty->load_filter('output', 'compress'); // load output filter named 'compress'</programlisting>
</example>
        </sect1>
		<sect1 id="api.register.block">
			<title>register_block</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_block</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>mixed <parameter>impl</parameter></paramdef>
				<paramdef>bool <parameter>cacheable</parameter></paramdef>
				<paramdef>array or null <parameter>cache_attrs</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
             Use isso para registrar dinamicamente blocos de funções de plugins.
	     Passe no bloco de nomes de função, seguido por uma chamada de função PHP
	     que implemente isso. 
			</para>

			<para>
             A chamada de uma função-php <parameter>impl</parameter> pode ser (a)
	     uma string contendo o nome da função ou (b) um array no formato
             <literal>array(&amp;$object, $method)</literal> com
             <literal>&amp;$object</literal> sendo uma referência para um
             objeto e <literal>$method</literal> sendo uma string
             contendo o nome do método ou (c) um array no formato
             <literal>array(&amp;$class, $method)</literal> com
             <literal>$class</literal> sendo um nome de classe e
             <literal>$method</literal> sendo um 
             método desta classe.
			</para>
			<para>
<parameter>$cacheable</parameter> e <parameter>$cache_attrs</parameter> podem ser omitidos na maior parte dos casos. Veja <link linkend="caching.cacheable">Controlando modos de Saída de Cache dos Plugins</link> para obter informações apropriadas.
			</para>
<example>
<title>register_block</title>
<programlisting>
/* PHP */
$smarty->register_block("translate", "do_translation");

function do_translation ($params, $content, &amp;$smarty, &amp;$repeat) {
    if (isset($content)) {
        $lang = $params['lang'];
        // do some translation with $content
        return $translation;
    }
}

{* template *}
{translate lang="br"}
   Hello, world!
{/translate}</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.compiler.function">
			<title>register_compiler_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_compiler_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>mixed <parameter>impl</parameter></paramdef>
				<paramdef>bool <parameter>cacheable</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use isso para registrar dinamicamente uma função de plugin compilador.
		Passe no nome da função compilador, seguido pela função 
		PHP que implemente isso.
			</para>
			<para>
                A chamada para função-php <parameter>impl</parameter> 
		pode ser uma string contendo o nome da função ou (b) um array
		no formato <literal>array(&amp;$object, $method)</literal> com
		<literal>&amp;$object</literal> sendo uma referência para um
		objeto e <literal>$method</literal> sendo uma string
		contendo o nome do método ou (c) um array no formato
		<literal>array(&amp;$class, $method)</literal> com
		<literal>$class</literal> sendo um nome de classe e 
		<literal>$method</literal> sendo o método
		desta classe.
			</para>
			<para>
                <parameter>$cacheable</parameter> pode ser omitido na maioria
                dos casos. Veja <link linkend="caching.cacheable">Controlando modos de Saída de Cache dos Plugins</link> 
		para obter informações apropriadas.
			</para>
		</sect1>
		<sect1 id="api.register.function">
			<title>register_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>mixed <parameter>impl</parameter></paramdef>
				<paramdef>bool <parameter>cacheable</parameter></paramdef>
				<paramdef>array or null <parameter>cache_attrs</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
	     Use isso para registrar funções de plugins dinamicamente para o template.
	     Passe no template o nome da função, 
	     seguido pelo nome da função PHP que implemente isso.
			</para>
			<para>
             A chamada para função-php <parameter>impl</parameter> pode ser (a) 
	     uma string contendo o nome da função ou (b) um array no formato
	     <literal>array(&amp;$object, $method)</literal> com
             <literal>&amp;$object</literal> sendo uma referência para um
             objeto e <literal>$method</literal> sendo uma string
             contendo o nome do método ou (c) um array no formato
             <literal>array(&amp;$class, $method)</literal> com
             <literal>$class</literal> sendo um nome de classe e 
             <literal>$method</literal> sendo um método
             desta classe.
                        </para>
			<para>
<parameter>$cacheable</parameter> e <parameter>$cache_attrs</parameter> podem ser omitidos na maioria dos casos. Veja <link linkend="caching.cacheable">Controlando modos de Saída Cache dos Plugins</link> para obter informações apropriadas.
			</para>
<example>
<title>register_function</title>
<programlisting>
$smarty->register_function("date_now", "print_current_date");

function print_current_date ($params) {
    extract($params);
    if(empty($format))
        $format="%b %e, %Y";
    return strftime($format,time());
}

// agora você pode usar isso no Smarty para mostrar a data atual: {date_now}
// ou, {date_now format="%Y/%m/%d"} para formatar isso.</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.modifier">
         <title>register_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>mixed <parameter>impl</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	  Use isso para modificar dinamicamente plugins registrados.
	  Passe no template o nome do modificador, seguido da função PHP
	  que implemente isso.
         </para>
         <para>
	  A chamada da função-php <parameter>impl</parameter> 
	  pode ser (a) uma strin contendo o nome da função
	  ou (b) um array no formato
	  <literal>array(&amp;$object, $method)</literal> com
	  <literal>&amp;$object</literal> sendo uma referência para um
	  objeto e <literal>$method</literal> sendo uma string
	  contendo o nome do método ou (c) um array no formato
	  <literal>array(&amp;$class, $method)</literal> com
	  <literal>$class</literal> sendo um nome de classe e
	  <literal>$method</literal> sendo um método desta classe.
	</para>

<example>
<title>register_modifier</title>
<programlisting>
// let's map PHP's stripslashes function to a Smarty modifier.

$smarty->register_modifier("sslash","stripslashes");

// now you can use {$var|sslash} to strip slashes from variables</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.object">
			<title>register_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
				<paramdef>object <parameter>$object</parameter></paramdef>
				<paramdef>array <parameter>allowed methods/properties</parameter></paramdef>
				<paramdef>boolean <parameter>format</parameter></paramdef>
				<paramdef>array <parameter>block methods</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
            <para>
			Isso é para registrar um objeto para uso no template. Veja a
			<link linkend="advanced.features.objects">seção de objetos</link>
			do manual para examplos.
            </para>
		</sect1>
		<sect1 id="api.register.outputfilter">
			<title>register_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_outputfilter</function></funcdef>
				<paramdef>mixed <parameter>function</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
                <para>
                 Use isso para registrar dinamicamente filtros de saída para operações
		 na saída do template antes de mostrá-lo. Veja
                 <link linkend="advanced.features.outputfilters">Filtros de Saída de Templates</link>
                 para maiores informações de como configurar uma
                 função de filtro de saída. 
                </para>
                <para>
                 A chamada da função-php <parameter>function</parameter> pode
		 ser (a) uma string contendo um nome de função ou (b) um array no formato
                 <literal>array(&amp;$object, $method)</literal> com
                 <literal>&amp;$object</literal> sendo uma referência para um
                 objeto e <literal>$method</literal> sendo uma string
                 contendo o nome do método ou (c) um array no formato
                 <literal>array(&amp;$class, $method)</literal> com
                 <literal>$class</literal> sendo um nome de classe e
                 <literal>$method</literal> sendo um método
                 desta classe.
                </para>
		</sect1>
		<sect1 id="api.register.postfilter">
			<title>register_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_postfilter</function></funcdef>
				<paramdef>mixed <parameter>function</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
	        Use isso para registrar dinamicamente pósfiltros para rodar templates
		após eles terem sido compilados. Veja   
                 <link linkend="advanced.features.postfilters">pósfiltros de template</link> para
		maiores informações de como configurar funções de pósfiltragem.
			</para>
            <para>
	         A chamada da função-php <parameter>function</parameter> pode
		 ser (a) uma string contendo um nome de função ou (b) um array no formato
                 <literal>array(&amp;$object, $method)</literal> com
                 <literal>&amp;$object</literal> sendo uma referência para um
                 objeto e <literal>$method</literal> sendo uma string
                 contendo o nome do método ou (c) um array no formato
                 <literal>array(&amp;$class, $method)</literal> com
                 <literal>$class</literal> sendo um nome de classe e
                 <literal>$method</literal> sendo um método
                 desta classe.
            </para>
		</sect1>
		<sect1 id="api.register.prefilter">
			<title>register_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_prefilter</function></funcdef>
				<paramdef>mixed <parameter>function</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
		Use isso para registrar préfiltros dinamicamente para rodar
		templates antes deles serem compilados. Veja <link
                linkend="advanced.features.prefilters">template prefilters</link> para
                maiores informações de como configurar uma função de préfiltragem.
			</para>
                        <para>
                 A chamada da função-php <parameter>function</parameter> pode
		 ser (a) uma string contendo um nome de função ou (b) um array no formato
                 <literal>array(&amp;$object, $method)</literal> com
                 <literal>&amp;$object</literal> sendo uma referência para um
                 objeto e <literal>$method</literal> sendo uma string
                 contendo o nome do método ou (c) um array no formato
                 <literal>array(&amp;$class, $method)</literal> com
                 <literal>$class</literal> sendo um nome de classe e
                 <literal>$method</literal> sendo um método
                 desta classe.
                        </para>
		</sect1>
        <sect1 id="api.register.resource">
         <title>register_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>array <parameter>resource_funcs</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use isso para registrar dinamicamente um recurso de plugin com a Smarty.
	      Passe no nome o recurso e o array de funções
	      PHP que implementam isso. Veja
          <link linkend="template.resources">template resources</link>
          para maiores informações de como configurar uma função para retornar
	  templates. 
         </para>
		 <note>
		 <title>Notas Técnicas</title>
		 <para>
		 Um nome de recurso deve ter ao menos dois caracteres de comprimento.
		 Um caracter do nome de recurso irá ser ignorado e usado como parte do
		 path do arquivo como, $smarty->display('c:/path/to/index.tpl');
		 </para>
		 </note>
         <para>
          A função-php-array <parameter>resource_funcs</parameter>
          deve ter 4 ou 5 elementos. Com 4 elementos os elementos são
	      as functions-callbacks para as respectivas funções "source",
          "timestamp", "secure" e "trusted" de recurso.
          Com 5 elementos o primeiro elemento tem que ser um objeto por referência
	      ou um nome de classe do objeto ou uma classe implementando o recurso e os 4
	      elementos seguintes tem que ter os nomes de métodos
	      implementando "source", "timestamp",
          "secure" e "trusted".
         </para>
<example>
<title>register_resource</title>
<programlisting>
$smarty->register_resource("db", array("db_get_template",
                                       "db_get_timestamp",
                                       "db_get_secure",
                                       "db_get_trusted"));</programlisting>
</example>
		</sect1>
        <sect1 id="api.trigger.error">
         <title>trigger_error</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>trigger_error</function></funcdef>
           <paramdef>string <parameter>error_msg</parameter></paramdef>
           <paramdef>[int <parameter>level</parameter>]</paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	 Essa função pode ser usada para saída de uma mensagem de erro usando Smarty.
	 O parâmetro <parameter>level</parameter> pode ser um dos valores usados 
	 para a função de php trigger_error(), ex.: E_USER_NOTICE,
          E_USER_WARNING, etc. Por padrão é E_USER_WARNING.
         </para>
        </sect1>

        <sect1 id="api.template.exists">
         <title>template_exists</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>bool <function>template_exists</function></funcdef>
           <paramdef>string <parameter>template</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Essa função checa se o template especificado existe. Isso pode
	  aceitar um path para o template no filesystem ou um recurso de string
	  especificando o template.
         </para>
        </sect1>
        <sect1 id="api.unregister.block">
         <title>unregister_block</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_block</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	 Use isso para desregistrar dinamicamente um bloco de funções de plugin.
	 Passe no bloco o nome da função.
         </para>
		</sect1>
        <sect1 id="api.unregister.compiler.function">
         <title>unregister_compiler_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_compiler_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	  Use essa função para desregistrar uma função de compilador. Passe
	  o nome da função de compilador.
         </para>
        </sect1>
		<sect1 id="api.unregister.function">
         <title>unregister_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	  Use isso para desregistrar dinamicamente uma função de plugin do template.
          Passe no template o nome da função.
         </para>
<example>
<title>unregister_function</title>
<programlisting>
// nós não queremos que designers template tenham acesso aos nossos arquivos do sistema

$smarty->unregister_function("fetch");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.modifier">
         <title>unregister_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	  Use isso para desregistrar dincamimente um modificador de plugin.
	  Passe no template o nome do modificador.
         </para>
<example>
<title>unregister_modifier</title>
<programlisting>
// nós não queremos que designers de template usem strip tags para os elementos

$smarty->unregister_modifier("strip_tags");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.object">
			<title>unregister_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use isso para desregistrar um objeto.
			</para>
		</sect1>
		<sect1 id="api.unregister.outputfilter">
			<title>unregister_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
		Use isso para desregistrar dinamicamente um filtro de saída.
			</para>
		</sect1>
		<sect1 id="api.unregister.postfilter">
			<title>unregister_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
		Use isso para dinamicamente desregistrar um pósfiltro.
			</para>
		</sect1>
		<sect1 id="api.unregister.prefilter">
			<title>unregister_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
		Use isso para dinamicamente desregistrar um préfiltro.
			</para>
		</sect1>
        <sect1 id="api.unregister.resource">
         <title>unregister_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
	  Use isso para dinamicamente desregistrar um recurso de plugin.
	  Passe no parâmetro nome o nome do recurso.
         </para>
<example>
<title>unregister_resource</title>
<programlisting>
$smarty->unregister_resource("db");</programlisting>
</example>
		</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

